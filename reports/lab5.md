## 实验报告
实现死锁检测功能，很长时间都没想明白这个算法怎么就能检测死锁。实现上是 可以在用户程序尝试获取锁/资源时，检测是否有可能发生死锁，即根据已有锁分配信息 和各线程锁需求信息 判断 最终是否有任务不能完成的情况，如果最终有任务不能完成就说明可能出现死锁 ， 这次请求资源就返回 -0dead。否则这次申请的锁资源就给应用程序。实现的时候开始只考虑了本次申请的锁/资源情况，导致 mutex1 和 sem2 测例能通过而 sem1 不行。后来发现得考虑所有线程锁申请情况才能比较准确的判断，而如果只考虑本次资源锁情况，会导致不需要这个锁而需要其他锁的线程表现为能完成，最终导致死锁检测失败。中间不知道为什么卡住了还以为是在等待锁，之后调整日志等级才发现是sys_time没有实现，解决了才能继续。完成后又将之前用全局变量实现的allcation/available/needed 转到进程控制块中。

实验总共占了三四天吧。


## 问答作业
1. 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 - 需要回收的资源有哪些？ - 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？

主线程自己使用的资源 + 其他线程 内核栈（exit_code 返回值还保存在这里），子线程TCB

其他线程的TCB 在主线程 tasks 字段中， 锁机制数据结构带的等待队列中 有引用，不需要回收，主线程结束后 TCB 引用减到 0，自动回收。

2. 对比以下两种 Mutex.unlock 的实现，二者有什么区别？这些区别可能会导致什么问题？

后者直接将锁资源移交给等待最久的线程，如果没有阻塞线程 才去修改标记。而前者先修改locked标记，然后会唤醒阻塞的任务,  如果一个任务调用mutex.lock阻塞了，后续有资源时，唤醒这个任务后，又一次申请这个资源（即第二次mutex.lock），如果先赋值locked标记，将会导致其再一次尝试获取锁时能成功继续往下走，也就是一个任务连续两次mutex.lock 可能不会阻塞。

## 局限
allocation/needed/available 使用vec不方便用下标取数，用的数组，数组必须是定长的，所以资源种类数量和线程总数就有了局限。如果设置大了，heap allocation 就会失败。如果用vec,然后用v.get(i),v.get_mut(i) 或许也可以。